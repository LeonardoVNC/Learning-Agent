generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===========================
 * Auth and User
 * ===========================
 */

model User {
  id        String   @id @default(uuid())
  name      String
  lastname  String
  email     String   @unique
  password  String
  isActive  Boolean  @default(true)

  // relation 1:N
  roles    UserRole[]
  sessions UserSession[]

  //Profiles 1:1
  teacherProfile TeacherProfile? @relation("UserTeacherProfile")
  studentProfile StudentProfile? @relation("UserStudentProfile")

  // Documentos subidos
  documents Document[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * ===========================
 * Role and permission (RBAC)
 * ===========================
 */

model Role {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?
  users       UserRole[]
  permissions RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
}

model Permission {
  id          String           @id @default(uuid())
  action      String
  resource    String
  description String?
  roles       RolePermission[]

  // Key unique
  @@unique([action, resource], map: "action_resource")
}

model UserRole {
  userId String
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
}

model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

/**
 * ===========================
 * Profile 1:1
 * ===========================
 */

model TeacherProfile {
  userId       String  @id
  user         User    @relation("UserTeacherProfile", fields: [userId], references: [id], onDelete: Cascade)
  title        String? // Ing., Mgr., PhD, etc.
  bio          String?
  academicUnit String?  // departamento/escuela

  // relation 1:N
  courses      Course[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model StudentProfile {
  userId        String  @id
  user          User    @relation("UserStudentProfile", fields: [userId], references: [id], onDelete: Cascade)
  code          String  @unique
  career        String? // Sistemas, Arquitectura....
  admissionYear Int?
  // relation 1:N
  enrollment    Enrollment[]
  attendance    Attendance[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

/**
 * ===========================
 * Sessions (login)
 * ===========================
 */

model UserSession {
  id            String   @id @default(uuid())
  userId        String
  token         String
  refresh_token String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())
  expiresAt     DateTime
  ipAddress     String?
  userAgent     String?

  @@index([userId, expiresAt])
}

model Document {
  id          String   @id @default(uuid())
  originalName String
  storedName   String   @unique
  s3Key        String
  size         Int
  contentType  String
  fileHash         String                    @unique // Hash SHA-256 del archivo
  textHash         String?                   @unique // Hash SHA-256 del texto normalizado
  extractedText    String?                   @db.Text // Texto extraído
  status           DocumentStatus            @default(UPLOADED)

  // Metadata del documento
  uploadedBy       String
  uploader         User                      @relation(fields: [uploadedBy], references: [id])

  // Relación opcional con Course/Materia para el contrato de documentos
  courseId         String?
  course           Course?                   @relation(fields: [courseId], references: [id])

  // Relación opcional con Classes/Período para documentos específicos de un período
  classId          String?
  class            Classes?                  @relation(fields: [classId], references: [id])

  // Relations para RAG
  chunks           DocumentChunk[]
  categories       DocumentCategoryMapping[]
  processingJobs   ProcessingJob[]
  documentIndex    DocumentIndex?
  
  // Información adicional extraída
  pageCount        Int?                      // Número de páginas (PDFs)
  documentTitle    String?                   // Título extraído del documento
  documentAuthor   String?                   // Autor extraído
  language         String?                   // Idioma detectado

  uploadedAt   DateTime @default(now())
  updatedAt        DateTime                  @updatedAt

  @@index([status])
  @@index([uploadedBy])
  @@index([fileHash])
  @@index([textHash])
  @@index([contentType])
  @@index([courseId])
}

model DocumentChunk {
  id              String    @id @default(uuid())
  documentId      String
  document        Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  content         String    @db.Text         // Contenido del chunk
  chunkIndex      Int                        // Índice del chunk en el documento
  startPosition   Int                        // Posición de inicio en el texto original
  endPosition     Int                        // Posición de fin en el texto original
  pageNumber      Int?                       // Página de origen (si aplica)
  type            String    @default("text") // Tipo de chunk (text, heading, list, etc.)

  // Metadata estadística
  wordCount       Int       @default(0)      // Número de palabras
  charCount       Int       @default(0)      // Número de caracteres

  // pgvector para embeddings
  embedding       Unsupported("public.vector(1536)")? // OpenAI embeddings (1536 dimensiones)

  // Metadata adicional del chunk
  metadata        Json?                      // Información contextual adicional

  // Campo para soft delete 
  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@index([isActive])
  @@index([type])
  @@index([wordCount])
  // Índice HNSW para búsqueda vectorial eficiente
  // CREATE INDEX CONCURRENTLY document_chunks_embedding_hnsw_idx ON "DocumentChunk" USING hnsw (embedding vector_cosine_ops);
  @@map("document_chunks")
}

model DocumentCategory {
  id          String                      @id @default(uuid())
  name        String                      @unique
  description String?
  color       String?                     // Color para UI
  icon        String?                     // Icono para UI

  documents   DocumentCategoryMapping[]

  createdAt   DateTime                    @default(now())
  updatedAt   DateTime                    @updatedAt
}

model DocumentCategoryMapping {
  documentId   String
  categoryId   String
  document     Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  category     DocumentCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  createdAt    DateTime         @default(now())

  @@id([documentId, categoryId])
}

model ProcessingJob {
  id           String           @id @default(uuid())
  documentId   String
  document     Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)

  jobType      ProcessingType
  status       ProcessingStatus @default(PENDING)
  errorMessage String?          @db.Text
  progress     Int              @default(0)     // Progreso 0-100

  // Detalles específicos del job
  jobDetails   Json?            // Configuración específica del job
  result       Json?            // Resultado del procesamiento

  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime         @default(now())

  @@index([documentId, jobType])
  @@index([status])
  @@index([createdAt])
}

/**
 * ===========================
 * Document Index Models
 * ===========================
 */

model DocumentIndex {
  id          String    @id @default(uuid())
  documentId  String    @unique
  document    Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  title       String
  status      IndexStatus @default(GENERATED)
  
  // Metadatos de generación
  generatedAt DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Configuración usada para generar el índice
  config      Json?     // Configuración de generación (idioma, nivel de detalle, etc.)
  
  // Relaciones con capítulos
  chapters    IndexChapter[]
  
  @@index([documentId])
  @@index([status])
  @@map("document_indexes")
}

model IndexChapter {
  id          String    @id @default(uuid())
  indexId     String
  index       DocumentIndex @relation(fields: [indexId], references: [id], onDelete: Cascade)
  
  title       String
  description String?   @db.Text
  order       Int       // Orden del capítulo en el índice
  
  // Relaciones
  subtopics   IndexSubtopic[]
  exercises   IndexExercise[]
  
  createdAt   DateTime  @default(now())
  
  @@index([indexId, order])
  @@map("index_chapters")
}

model IndexSubtopic {
  id          String    @id @default(uuid())
  chapterId   String
  chapter     IndexChapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  
  title       String
  description String?   @db.Text
  order       Int       // Orden del subtema en el capítulo
  
  // Relaciones
  exercises   IndexExercise[]
  
  createdAt   DateTime  @default(now())
  
  @@index([chapterId, order])
  @@map("index_subtopics")
}

model IndexExercise {
  id            String    @id @default(uuid())
  
  // Puede pertenecer a un capítulo o a un subtema
  chapterId     String?
  subtopicId    String?
  chapter       IndexChapter? @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  subtopic      IndexSubtopic? @relation(fields: [subtopicId], references: [id], onDelete: Cascade)
  
  type          ExerciseType
  title         String
  description   String    @db.Text
  difficulty    ExerciseDifficulty
  estimatedTime String?   // Ej: "15 minutos"
  keywords      String[]  // Array de palabras clave
  
  order         Int       // Orden del ejercicio
  
  createdAt     DateTime  @default(now())
  
  @@index([chapterId])
  @@index([subtopicId])
  @@index([type])
  @@index([difficulty])
  @@map("index_exercises")
}

/**
 * ===========================
 * Enums para Document Processing
 * ===========================
 */

enum DocumentStatus {
  UPLOADED      // Archivo subido, esperando procesamiento
  PROCESSING    // En proceso de extracción/chunking/embedding
  PROCESSED     // Completamente procesado y listo para búsqueda
  ERROR         // Error en el procesamiento
  DELETED       // Marcado como eliminado
}

enum ProcessingType {
  TEXT_EXTRACTION       // Extraer texto del archivo
  CHUNKING             // Dividir texto en chunks
  EMBEDDING_GENERATION // Generar embeddings vectoriales
  FULL_PROCESSING      // Procesamiento completo (todos los pasos)
  REPROCESSING         // Reprocesar documento existente
}

enum ProcessingStatus {
  PENDING      // Esperando en cola
  RUNNING      // Ejecutándose actualmente
  COMPLETED    // Completado exitosamente
  FAILED       // Falló con error
  CANCELLED    // Cancelado manualmente
  RETRYING     // Reintentando después de fallo
}

enum ChunkType {
  TEXT         // Chunk de texto normal
  TITLE        // Título o encabezado
  TABLE        // Contenido de tabla
}

enum IndexStatus {
  GENERATING   // Índice en proceso de generación
  GENERATED    // Índice generado exitosamente
  ERROR        // Error en la generación
  OUTDATED     // Índice desactualizado (documento modificado)
}

enum ExerciseType {
  CONCEPTUAL      // Preguntas conceptuales
  PRACTICAL       // Ejercicios prácticos
  ANALYSIS        // Análisis de casos
  SYNTHESIS       // Síntesis de información
  APPLICATION     // Aplicación de conceptos
  PROBLEM_SOLVING // Resolución de problemas
}

enum ExerciseDifficulty {
  BASIC           // Nivel básico
  INTERMEDIATE    // Nivel intermedio
  ADVANCED        // Nivel avanzado
}

/**
 * ===========================
 * Exams generation
 * ===========================
 */

// ---------- Enums ----------
enum QuestionKind {
  MULTIPLE_CHOICE
  TRUE_FALSE
  OPEN_ANALYSIS
  OPEN_EXERCISE
}

enum ExamStorageStatus {
  Guardado
  Publicado
}

model Exam {
  id             String            @id @default(uuid())
  title          String            @default("Examen")
  difficulty     String
  attempts       Int
  timeMinutes    Int
  reference      String?           @db.Text
  status         ExamStorageStatus @default(Guardado)

  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // relation 1:N (Classes → Exams)
  classId        String
  class          Classes           @relation("ClassExams", fields: [classId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  // questions
  questions      ExamQuestion[]

  @@index([classId, createdAt])
  @@index([title])
  @@index([difficulty])
}

model ExamQuestion {
  id        String       @id @default(cuid())
  examId    String
  exam      Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)

  kind      QuestionKind
  text      String
  order     Int

  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  mcq        MCQ?
  trueFalse  TrueFalse?
  openAnalysis  OpenAnalysis?
  openExercise  OpenExercise?

  @@unique([examId, order])
  @@index([examId, order])
}

// ---------- Subtypes (1:1 with ExamQuestion) ----------
model MCQ {
  questionId         String     @id
  question           ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  correctOptionIndex Int

  // options (1:N)
  options            MCQOption[]

  @@index([correctOptionIndex])
}

model MCQOption {
  id     String @id @default(cuid())
  mcqId  String
  mcq    MCQ    @relation(fields: [mcqId], references: [questionId], onDelete: Cascade)

  // display order and text
  idx    Int
  text   String

  @@unique([mcqId, idx])
  @@index([mcqId])
}

model TrueFalse {
  questionId String       @id
  question   ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  answer     Boolean
}

model OpenAnalysis {
  questionId     String       @id
  question       ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  expectedAnswer String
}

model OpenExercise {
  questionId     String       @id
  question       ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  expectedAnswer String
}


/* ===========================
   Academic Management (classes and enrollment)
   =========================== */

model Course {
  id            String            @id @default(uuid())
  name          String
  isActive      Boolean           @default(true)

  teacherId     String
  teacher       TeacherProfile    @relation(fields: [teacherId], references: [userId])
  classes       Classes[]

  // Relación con documentos para el contrato
  documents     Document[]

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
}

model Classes {
  id            String            @id @default(uuid())
  name          String
  semester      String
  isActive      Boolean           @default(true)
  dateBegin     DateTime
  dateEnd       DateTime

  // relation 1:N
  enrollment    Enrollment[]
  attendance Attendance[]
  documents     Document[]        // Documentos específicos para este período/clase

  quizQuestions    QuizQuestion[]
  interviewQuestions InterviewQuestion[]


  courseId      String
  course        Course            @relation(fields: [courseId], references: [id])

  // relation 1:N
  exams         Exam[]            @relation("ClassExams")
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt @default(now())
}

// relation N:N - StudentProfile-Classes
model Enrollment {
  studentId     String
  student       StudentProfile    @relation(fields: [studentId], references: [userId])
  classId       String
  class         Classes           @relation(fields: [classId], references: [id])
  isActive      Boolean           @default(true)

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@id([studentId, classId])
}


/* ===========================
   Reinforcement (entrevistas y examenes )
   =========================== */
   model QuizQuestion {
    id         String   @id @default(uuid())
    classId    String
    text       String   @db.Text
    type       String
    options    Json?
    createdAt  DateTime @default(now())
    lastUsedAt DateTime?

    // Relación con Classes
    class      Classes  @relation(fields: [classId], references: [id], onDelete: Cascade)
    @@index([classId])
    @@index([createdAt])
    @@index([lastUsedAt])
    @@map("quiz_questions")
  }

  model InterviewQuestion {
    id         String   @id @default(uuid())
    classId    String
    text       String   @db.Text
    createdAt  DateTime @default(now())
    lastUsedAt DateTime?

    // Relación con Classes
    class      Classes  @relation(fields: [classId], references: [id], onDelete: Cascade)
    @@index([classId])
    @@index([createdAt])
    @@index([lastUsedAt])
    @@map("interview_questions")
  }
// relation N:N - StudentProfile-Classes by Dates
model Attendance {
  id            String            @id @default(uuid())

  studentId     String
  student       StudentProfile    @relation(fields: [studentId], references: [userId])
  classId       String
  class         Classes           @relation(fields: [classId], references: [id])

  date          DateTime          @default(now())
  isPresent     Boolean           @default(false)

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
}